# 리눅스 메모리 구조
----------------------------------------
## 세그먼트
- 리눅스에서는 프로세스의 메모리를 크게 5가지의 세그먼트로 구분한다.
  - 세그먼트란, 적재되는 데이터의 용도별로 메모리의 구획을 나눈 것이다.
  ![Alt text](/seg.png)
  - 용도별로 메모리를 나눈 이유 => 각 용도에 맞게 권한을 적절히 부여 가능
    - 권한은 <r> 읽기, 쓰기, 실행 </r> 이렇게 존재한다.

### 1. 코드 세그먼트(텍스트 세그먼트)
- 실행 가능한 기계 코드가 위치하는 영역
- 읽기와 실행 권한 가짐
  - 쓰기 권한이 있으면 다른 사용자가 악의적인 코드를 써서 실행할 수도 있기 때문임
- ex. 정수 31337을 반환하는 main함수로 컴파일되면 554889e5b8697a00005dc3라는 기계 코드로 변환되며 이 코드가 코드 세그먼트에 위치함
~~~cpp
int main() { return 31337; }
~~~

### 2. 데이터 세그먼트
- 컴파일 시점에 값이 정해진 전역 변수 및 전역 상수들이 위치함
- CPU가 이 세그먼트의 데이터를 읽을 수 있어야 하므로 읽기 권한이 부여됨
  - but. 쓰기가 가능한 세그먼트와 불가능한 세그먼트로 다시 분류됨
    - __data 세그먼트__ = 쓰기가 가능한 세그먼트로 전역 변수와 같이 프로그램이 실행되면서 값이 변할 수 있는 데이터들이 위치함
    - __rodata(read-only-data)세그먼트__ = 값이 변하면 안되는 데이터들이 위치함.(ex. 전역으로 선언된 상수)
  - ex.
~~~cpp
int data_num = 31337;                       // data
char data_rwstr[] = "writable_data";        // data
const char data_rostr[] = "readonly_data";  // rodata
char *str_ptr = "readonly";  // str_ptr은 data, 문자열은 rodata

int main() { ... }
~~~
1. 'data_num'은 초기화된 전역변수로 나중에 'data_num = 10000;' 처럼 변경 가능
2. 'data_rwstr[]'은 배열이므로 'writable_data' 문자열이 data 세그먼트에 저장됨
   - 중요한 점.
     - 'writable_data' 문자열은 스택이 아닌 data 세그먼트에 저장됨
     - 즉 'data_rwstr'은 data 세그먼트에 자체적으로 저장된 배열이므로 변경 가능한 것임
3. 'const char data_rostr[]'은 상수 배열이므로 rodata에 저장됨
4. 'str_ptr' data, 문자열은 rodata에 저장됨
   - 'char *str_ptr'은 문자열이 저장된 주소를 가리키는 포인터 변수이므로 data에 저장됨

### 3. BSS 세그먼트
- BSS 세그먼트는 컴파일 시점에서 값이 정해지지 않은 전역 변수가 위치하는 메모리 영역임
  - 프로그램이 시작될 때 이 세그먼트에 위치한 변수들은 모두 0으로 초기화됨
- ex. 여기서 초기화되지 않은 전역변수인 'bss_data'가 BSS 세그먼트에 위치함
~~~cpp
int bss_data;

int main() {
  printf("%d\n", bss_data);  // 0
  return 0;
}
~~~

### 4. 스택 세그먼트
- 프로세스의 스택이 위치하는 영역으로 함수의 인자, 지역 변수와 같은 임시 변수들이 실행중에 여기에 저장됨
- 스택 프레임이란 단위로 사용되며 스택 프레임은 함수가 호출될 때 생성되며 반환할 때 해제된다
  - but, 사용자의 입력에 따라 실행흐름이 좌우되어 여러 요인에 영향을 받음
- ex. 여기서 call_true()가 호출될지 call_false()가 호출될지 모름
~~~cpp
void func() {
  int choice = 0;

  scanf("%d", &choice);

  if (choice)
    call_true();
  else
    call_false();

  return 0;
}
~~~
  - 이러한 이유때문에 프로세스가 실행될 때 얼마만큼의 스택 프레임을 차지하는지 계산x
    - > 그래서 운영체제는 프로세스 시작시 작은 크기의 스택 세그먼트을 먼저 할당하고 부족할 때마다 확장시킴
    - > 이러한 표현을 스택이 아래로 자란다라고 하는데 이는 확장할 때 기존 주소에서 낮은 주소로 확장시키기 때문임
    - > 읽고 쓰는 것이 자유로워야 하므로 읽기, 쓰기 권한이 있음
- > 위 코드에서는 'choice'가 스택에 저장됨

### 5. 힙 세그먼트
- 힙 데이터가 위치하며 스택 세그먼트와 마찬가지로 실행중에 동적으로 할당될 수 있고, 스택 세그먼트와 반대방향으로 자람
- 보통 c언어에서 malloc(), calloc() 등을 호출해서 할당받는 메모리가 여기 위치하며 읽기, 쓰기 권한 부여됨
- ex.아래 코드에서 'heap_data_ptr'에 malloc()으로 동적 할당한 영역의 주소를 대입하고 이 영역에 값을 쓴다.
  - 이후 heap_data_ptr은 지역변수이므로 스택에 위치하며, malloc으로 할당받은 힙 세그먼트의 주소를 가리킴킴
~~~cpp
int main() {
  int *heap_data_ptr =
      malloc(sizeof(*heap_data_ptr));  // 동적 할당한 힙 영역의 주소를 가리킴
  *heap_data_ptr = 31337;              // 힙 영역에 값을 씀
  printf("%d\n", *heap_data_ptr);  // 힙 영역의 값을 사용함
  return 0;
}
~~~